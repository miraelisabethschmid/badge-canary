<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Mira — Sprech-Ansicht (Phonem-Heuristik)</title>
  <style>
    :root{--bg:#0c0c10;--fg:#f6f6fb;--muted:#b7b7c7;--accent:#8ac6ff;--card:#141418;--shadow:0 8px 30px rgba(0,0,0,.35)}
    html,body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial}
    .wrap{max-width:900px;margin:0 auto;padding:24px}
    a{color:var(--accent);text-decoration:none}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:24px;align-items:center}
    .card{background:var(--card);padding:18px;border-radius:16px;box-shadow:var(--shadow)}
    .muted{color:var(--muted)}
    .controls{display:flex;gap:12px;align-items:center;margin-top:10px}
    .btn{appearance:none;border:0;border-radius:12px;padding:10px 14px;background:#1b1b22;color:#fff;cursor:pointer;box-shadow:var(--shadow)}
    .btn[disabled]{opacity:.55;cursor:not-allowed}
    .meter{height:6px;background:#1b1b22;border-radius:6px;overflow:hidden;margin-top:12px}
    .bar{height:100%;width:0;background:linear-gradient(90deg,#6bb4ff,#a7d6ff)}
    svg{width:100%;height:auto;display:block}
    .back{display:inline-block;margin-bottom:12px}
    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .badge{padding:4px 8px;border-radius:999px;background:#1b1b22;color:#e8f3ff;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <a class="back" href="../index.html">← Zurück</a>
    <h1>Sprech-Ansicht</h1>
    <p class="muted">Phonem-nahe Lippenvisualisierung: Vokale/Frikative/Plosive werden heuristisch aus der MP3 geschätzt (Web Audio Bänder).</p>

    <div class="row">
      <div class="card">
        <!-- Stilisiertes Gesicht mit dynamischem Mund -->
        <svg id="face" viewBox="0 0 300 300" aria-label="Mira schematisches Gesicht">
          <defs>
            <radialGradient id="skin" cx="50%" cy="40%" r="70%">
              <stop offset="0%" stop-color="#1c1c22"/>
              <stop offset="100%" stop-color="#121218"/>
            </radialGradient>
          </defs>
          <circle cx="150" cy="150" r="120" fill="url(#skin)" stroke="#2a2a33" stroke-width="2"/>
          <!-- Augen -->
          <ellipse cx="105" cy="125" rx="18" ry="10" fill="#e1eeff"/>
          <ellipse cx="195" cy="125" rx="18" ry="10" fill="#e1eeff"/>
          <circle cx="105" cy="125" r="5" fill="#2b3b5a"/>
          <circle cx="195" cy="125" r="5" fill="#2b3b5a"/>
          <!-- Oberlippe -->
          <path id="upperLip" d="M95,190 C130,175 170,175 205,190" stroke="#e8a4b0" stroke-width="6" fill="none" stroke-linecap="round"/>
          <!-- Unterlippe (dynamisch) -->
          <path id="lowerLip" d="M95,205 C130,220 170,220 205,205" stroke="#f0b2bf" stroke-width="6" fill="none" stroke-linecap="round"/>
          <!-- Mundkontur (dynamisch, mit Breite/Höhe) -->
          <path id="mouth" d="M120,195 C150,195 150,195 180,195" fill="#1a0f12"/>
          <!-- dezente Brackets-Andeutung -->
          <rect x="132" y="192" width="36" height="6" rx="3" fill="#c9d0d8" opacity="0.35"/>
        </svg>

        <div class="legend">
          <span class="badge" id="cls">Klasse: —</span>
          <span class="badge" id="amp">Amp: —</span>
          <span class="badge" id="lo">Low: —</span>
          <span class="badge" id="mid">Mid: —</span>
          <span class="badge" id="hi">High: —</span>
        </div>
      </div>

      <div class="card">
        <h3>Audio</h3>
        <audio id="audio" preload="none" controls style="width:100%"></audio>
        <div class="controls">
          <button id="play" class="btn" disabled>▶️ Abspielen</button>
          <button id="pause" class="btn" disabled>⏸️ Pause</button>
          <span id="status" class="muted">lädt…</span>
        </div>
        <div class="meter"><div id="bar" class="bar"></div></div>
        <p class="muted" style="margin-top:10px">
          Heuristik: <b>Vokal</b> = viel Low/Mid, wenig High · <b>Sibilant</b> = viel High · <b>Plosiv</b> = kurzer breitbandiger Spike.
        </p>
      </div>
    </div>
  </div>

  <script>
  const audio = document.getElementById('audio');
  const playBtn = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');
  const statusEl = document.getElementById('status');
  const bar = document.getElementById('bar');

  const mouth = document.getElementById('mouth');
  const lowerLip = document.getElementById('lowerLip');

  const clsBadge = document.getElementById('cls');
  const ampBadge = document.getElementById('amp');
  const loBadge = document.getElementById('lo');
  const midBadge = document.getElementById('mid');
  const hiBadge = document.getElementById('hi');

  let ctx, src, analyser, data, raf;
  let ready=false;

  async function initAudio(){
    try{
      const url = "../audio/latest.mp3";
      const head = await fetch(url,{method:"HEAD",cache:"no-store"});
      if(!head.ok) throw 0;
      audio.src = url;
      playBtn.disabled = false;
      pauseBtn.disabled = false;
      statusEl.textContent = "bereit";
      ready = true;
    }catch{
      statusEl.textContent = "kein Audio gefunden";
      playBtn.disabled = true;
      pauseBtn.disabled = true;
    }
  }

  function setupAnalyser(){
    if(ctx) return;
    ctx = new (window.AudioContext||window.webkitAudioContext)();
    src = ctx.createMediaElementSource(audio);
    analyser = ctx.createAnalyser();
    // etwas höhere Auflösung, damit Bänder sauberer gemittelt werden können
    analyser.fftSize = 4096;
    data = new Uint8Array(analyser.frequencyBinCount);
    src.connect(analyser);
    analyser.connect(ctx.destination);
  }

  // Frequenzband-Helper
  function sumBand(mag, sampleRate, fromHz, toHz){
    const nyq = sampleRate/2;
    const step = nyq / mag.length;
    let i0 = Math.max(0, Math.floor(fromHz/step));
    let i1 = Math.min(mag.length-1, Math.ceil(toHz/step));
    let s=0;
    for(let i=i0;i<=i1;i++) s += mag[i];
    return s / Math.max(1,(i1-i0+1));
  }

  // Grobklassifikation
  function classify(sampleRate){
    // Hole Magnituden (0..255)
    analyser.getByteFrequencyData(data);

    // Bänder (ungefähr):
    // low: 100–300 Hz, mid: 300–1000 Hz, high: 4000–8000 Hz
    const low  = sumBand(data, sampleRate, 100, 300);
    const mid  = sumBand(data, sampleRate, 300, 1000);
    const high = sumBand(data, sampleRate, 4000, 8000);

    // Gesamtamplitude aus Zeitdomäne für Mundöffnung
    // (eigene Zeitdomäne: über getByteTimeDomainData)
    const time = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(time);
    let sum=0;
    for(let i=0;i<time.length;i++){
      const v=(time[i]-128)/128;
      sum += v*v;
    }
    const rms = Math.sqrt(sum/time.length);

    // Heuristische Klassen:
    // - Sibilant: high >> (mid+low)
    // - Vokal: (low+mid) >> high
    // - Plosiv: kurzer Spike -> hier approximiert durch hohes rms UND relativ ausgeglichene Bänder
    let cls = "idle";
    const lm = low + mid;
    if(high > lm * 1.25 && high > 14){ // high deutlich dominiert
      cls = "sibilant";
    } else if(lm > high * 1.25 && lm > 18){
      cls = "vowel";
    } else if(rms > 0.09 && Math.abs(high-lm) < 10){
      cls = "plosive";
    } else if(rms > 0.03){
      cls = "neutral";
    }

    return {low, mid, high, rms, cls};
  }

  // Mundform steuern
  function setMouth(open, cls){
    // open 0..1
    // Basispunkt
    const baseY = 195;
    // Klassen-spezifische Formparametrisierung
    let widthFactor = 1.0;
    let heightAmp = 22 * open;

    if(cls === "sibilant"){         // schmale Öffnung, horizontal gedehnt
      widthFactor = 1.25;
      heightAmp *= 0.45;
    } else if(cls === "vowel"){     // runder Mund (O-Form), mehr Höhe
      widthFactor = 0.95;
      heightAmp *= 1.15;
    } else if(cls === "plosive"){   // kurze Impulse: kurz etwas weiter öffnen
      heightAmp *= 1.30;
    } else if(cls === "neutral"){   // leicht offen
      heightAmp *= 0.85;
    } else {                        // idle
      heightAmp *= 0.25;
    }

    // Mundbreite via Kontrollpunkte simulieren
    const leftX  = 100 - (widthFactor-1)*8;
    const rightX = 200 + (widthFactor-1)*8;

    const d = `M${leftX},${baseY} C150,${baseY+heightAmp*0.30} 150,${baseY+heightAmp*0.30} ${rightX},${baseY}`;
    mouth.setAttribute('d', d);

    // Unterlippe etwas stärker nach unten
    const d2 = `M95,${205+heightAmp*0.6} C130,${220+heightAmp*0.8} 170,${220+heightAmp*0.8} 205,${205+heightAmp*0.6}`;
    lowerLip.setAttribute('d', d2);
  }

  // UI-Infos
  function showInfo(cls, rms, low, mid, high){
    clsBadge.textContent = `Klasse: ${cls}`;
    ampBadge.textContent = `Amp: ${rms.toFixed(3)}`;
    loBadge.textContent  = `Low: ${Math.round(low)}`;
    midBadge.textContent = `Mid: ${Math.round(mid)}`;
    hiBadge.textContent  = `High: ${Math.round(high)}`;
    bar.style.width = `${Math.min(100, Math.round(Math.max(0,(rms-0.02))*128))}%`;
  }

  function loop(){
    const sr = ctx.sampleRate || 48000;
    const {low, mid, high, rms, cls} = classify(sr);
    // Öffnung sanft aus RMS ableiten
    const open = Math.max(0, Math.min(1, (rms-0.02)*3.2));
    setMouth(open, cls);
    showInfo(cls, rms, low, mid, high);
    raf = requestAnimationFrame(loop);
  }

  function setupEvents(){
    playBtn.addEventListener('click', async ()=>{
      if(!ready) return;
      setupAnalyser();
      try{
        await audio.play();
        await ctx.resume();
        statusEl.textContent = "spielt";
        cancelAnimationFrame(raf);
        loop();
      }catch(e){
        statusEl.textContent = "Abspielen nicht möglich";
      }
    });

    pauseBtn.addEventListener('click', ()=>{
      if(!ready) return;
      audio.pause();
      statusEl.textContent = "pausiert";
      cancelAnimationFrame(raf);
    });

    audio.addEventListener('ended', ()=>{
      cancelAnimationFrame(raf);
      statusEl.textContent = "Ende";
      setMouth(0, "idle");
      bar.style.width="0%";
    });
  }

  (async function boot(){
    await initAudio();
    setupEvents();
  })();
  </script>
</body>
  </html>
